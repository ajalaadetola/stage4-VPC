# Create a new fixed vpcctl
cat > vpcctl << 'EOF'
#!/bin/bash

# vpcctl - Linux VPC Manager
# Complete working version

set -e

# Configuration
VPC_DIR="/tmp/vpc_configs"
LOG_FILE="logs/vpc-demo.log"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

log_debug() {
    echo -e "${BLUE}[DEBUG]${NC} $*"
}

# Initialize log
init_log() {
    mkdir -p "$(dirname "$LOG_FILE")"
    echo "=== VPC DEMO LOG - Started at $(date) ===" > "$LOG_FILE"
}

# Command execution
run_cmd() {
    local cmd="$1"
    log_debug "Executing: $cmd"
    if ! eval "$cmd" 2>/dev/null; then
        log_error "Command failed: $cmd"
        return 1
    fi
    return 0
}

# Network namespace operations
namespace_exists() {
    ip netns list | grep -q "$1" 2>/dev/null
}

create_namespace() {
    local ns="$1"
    if ! namespace_exists "$ns"; then
        log_info "Creating network namespace: $ns"
        run_cmd "ip netns add $ns"
    else
        log_warn "Namespace $ns already exists"
    fi
}

delete_namespace() {
    local ns="$1"
    if namespace_exists "$ns"; then
        log_info "Deleting network namespace: $ns"
        ip netns delete "$ns" 2>/dev/null || true
    fi
}

# Bridge operations
bridge_exists() {
    ip link show "$1" 2>/dev/null | grep -q "$1"
}

create_bridge() {
    local bridge="$1"
    if ! bridge_exists "$bridge"; then
        log_info "Creating bridge: $bridge"
        run_cmd "ip link add $bridge type bridge"
        run_cmd "ip link set $bridge up"
    else
        log_warn "Bridge $bridge already exists"
    fi
}

delete_bridge() {
    local bridge="$1"
    if bridge_exists "$bridge"; then
        log_info "Deleting bridge: $bridge"
        ip link set "$bridge" down 2>/dev/null || true
        ip link delete "$bridge" 2>/dev/null || true
    fi
}

# VPC configuration management
get_vpc_config_path() {
    echo "$VPC_DIR/$1.conf"
}

vpc_exists() {
    [ -f "$(get_vpc_config_path "$1")" ]
}

save_vpc_config() {
    local vpc_name="$1"
    local key="$2"
    local value="$3"
    
    local config_file="$(get_vpc_config_path "$vpc_name")"
    mkdir -p "$VPC_DIR"
    
    if [ ! -f "$config_file" ]; then
        touch "$config_file"
    fi
    
    # Remove existing key if present
    grep -v "^$key=" "$config_file" > "$config_file.tmp" 2>/dev/null || true
    mv "$config_file.tmp" "$config_file" 2>/dev/null || true
    
    # Add new key-value pair
    echo "$key=$value" >> "$config_file"
}

get_vpc_config() {
    local vpc_name="$1"
    local key="$2"
    local config_file="$(get_vpc_config_path "$vpc_name")"
    
    if [ -f "$config_file" ]; then
        grep "^$key=" "$config_file" | cut -d'=' -f2-
    fi
}

# Core VPC operations
create_vpc() {
    local vpc_name="$1"
    local cidr_block="$2"
    
    log_info "üöÄ Creating VPC: $vpc_name with CIDR: $cidr_block"
    
    # Check if VPC already exists
    if vpc_exists "$vpc_name"; then
        log_error "VPC $vpc_name already exists"
        return 1
    fi
    
    # Create bridge
    local bridge_name="br-$vpc_name"
    create_bridge "$bridge_name"
    
    # Assign IP to bridge (first IP in CIDR as gateway)
    local gateway_ip="${cidr_block%.*}.1"
    log_info "Assigning gateway IP: $gateway_ip to bridge $bridge_name"
    ip addr add "$gateway_ip/24" dev "$bridge_name" 2>/dev/null || true
    
    # Store VPC configuration
    save_vpc_config "$vpc_name" "CIDR" "$cidr_block"
    save_vpc_config "$vpc_name" "BRIDGE" "$bridge_name"
    save_vpc_config "$vpc_name" "GATEWAY" "$gateway_ip"
    save_vpc_config "$vpc_name" "SUBNETS" ""
    
    log_info "‚úÖ VPC $vpc_name created successfully"
}

create_subnet() {
    local vpc_name="$1"
    local subnet_name="$2"
    local subnet_cidr="$3"
    local subnet_type="${4:-private}"
    
    log_info "üîß Creating subnet: $subnet_name (CIDR: $subnet_cidr, Type: $subnet_type)"
    
    if ! vpc_exists "$vpc_name"; then
        log_error "VPC $vpc_name not found"
        return 1
    fi
    
    # Load VPC config
    local bridge_name=$(get_vpc_config "$vpc_name" "BRIDGE")
    local gateway_ip=$(get_vpc_config "$vpc_name" "GATEWAY")
    
    # Create network namespace for subnet
    local ns_name="ns-$vpc_name-$subnet_name"
    
    # Clean up existing namespace if it exists
    delete_namespace "$ns_name"
    create_namespace "$ns_name"
    
    # Create veth pair with unique names
    local veth_host="veth-$vpc_name-$subnet_name-host"
    local veth_ns="veth-$vpc_name-$subnet_name-ns"
    
    # Clean up any existing veth interfaces
    ip link delete "$veth_host" 2>/dev/null || true
    
    log_info "Creating veth pair: $veth_host <-> $veth_ns"
    
    # Create veth pair
    if ! ip link add "$veth_host" type veth peer name "$veth_ns"; then
        log_error "Failed to create veth pair"
        log_error "Trying workaround..."
        
        # Try alternative approach
        sleep 1
        if ! ip link add name "$veth_host" type veth peer name "$veth_ns"; then
            log_error "All veth creation methods failed"
            return 1
        fi
    fi
    
    # Move one end to subnet namespace
    log_info "Moving $veth_ns to namespace $ns_name"
    ip link set "$veth_ns" netns "$ns_name"
    
    # Add host end to bridge
    log_info "Connecting $veth_host to bridge $bridge_name"
    ip link set "$veth_host" master "$bridge_name"
    ip link set "$veth_host" up
    
    # Configure namespace side
    log_info "Configuring network in namespace $ns_name"
    ip netns exec "$ns_name" ip link set lo up
    ip netns exec "$ns_name" ip link set "$veth_ns" up
    ip netns exec "$ns_name" ip addr add "$subnet_cidr" dev "$veth_ns"
    
    # Set up routing
    log_info "Setting default route via gateway: $gateway_ip"
    ip netns exec "$ns_name" ip route add default via "$gateway_ip"
    
    # Store subnet configuration
    local current_subs=$(get_vpc_config "$vpc_name" "SUBNETS")
    if [ -z "$current_subs" ]; then
        save_vpc_config "$vpc_name" "SUBNETS" "$subnet_name"
    else
        save_vpc_config "$vpc_name" "SUBNETS" "$current_subs,$subnet_name"
    fi
    
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_NS" "$ns_name"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_CIDR" "$subnet_cidr"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_TYPE" "$subnet_type"
    
    log_info "‚úÖ Subnet $subnet_name created successfully in VPC $vpc_name"
}

list_vpcs() {
    log_info "üìã Listing all VPCs:"
    
    if [ ! -d "$VPC_DIR" ] || [ -z "$(ls -A "$VPC_DIR" 2>/dev/null)" ]; then
        echo "No VPCs found"
        return
    fi
    
    for config_file in "$VPC_DIR"/*.conf; do
        local vpc_name=$(basename "$config_file" .conf)
        local cidr=$(get_vpc_config "$vpc_name" "CIDR")
        local bridge=$(get_vpc_config "$vpc_name" "BRIDGE")
        local subnets=$(get_vpc_config "$vpc_name" "SUBNETS")
        
        echo ""
        echo "VPC: $vpc_name"
        echo "  CIDR: $cidr"
        echo "  Bridge: $bridge"
        echo "  Subnets: ${subnets:-None}"
        
        if [ -n "$subnets" ]; then
            IFS=',' read -ra subnet_array <<< "$subnets"
            for subnet in "${subnet_array[@]}"; do
                local subnet_cidr=$(get_vpc_config "$vpc_name" "SUBNET_${subnet}_CIDR")
                local subnet_type=$(get_vpc_config "$vpc_name" "SUBNET_${subnet}_TYPE")
                echo "    - $subnet: $subnet_cidr ($subnet_type)"
            done
        fi
    done
}

# Test connectivity
test_connectivity() {
    local vpc_name="$1"
    local subnet1="$2"
    local subnet2="$3"
    
    log_info "Testing connectivity: $subnet1 -> $subnet2"
    
    local ns1=$(get_vpc_config "$vpc_name" "SUBNET_${subnet1}_NS")
    local ip2=$(get_vpc_config "$vpc_name" "SUBNET_${subnet2}_CIDR" | cut -d'/' -f1)
    
    if ip netns exec "$ns1" ping -c 3 -W 1 "$ip2" 2>/dev/null; then
        log_info "‚úÖ Connectivity successful: $subnet1 can reach $subnet2"
        return 0
    else
        log_info "‚ùå Connectivity failed: $subnet1 cannot reach $subnet2"
        return 1
    fi
}

# Main CLI handler
main() {
    init_log
    
    case "$1" in
        create-vpc)
            if [ $# -lt 3 ]; then
                log_error "Usage: create-vpc <name> <cidr>"
                exit 1
            fi
            create_vpc "$2" "$3"
            ;;
        create-subnet)
            if [ $# -lt 4 ]; then
                log_error "Usage: create-subnet <vpc> <name> <cidr> [type]"
                exit 1
            fi
            create_subnet "$2" "$3" "$4" "$5"
            ;;
        list-vpcs)
            list_vpcs
            ;;
        test)
            if [ $# -lt 4 ]; then
                log_error "Usage: test <vpc> <subnet1> <subnet2>"
                exit 1
            fi
            test_connectivity "$2" "$3" "$4"
            ;;
        cleanup)
            log_info "Cleaning up..."
            rm -rf "$VPC_DIR"
            for ns in $(ip netns list | grep -o 'ns-[^ ]*'); do
                ip netns delete "$ns" 2>/dev/null || true
            done
            for bridge in $(ip link show type bridge 2>/dev/null | grep -o 'br-[^ ]*'); do
                ip link set "$bridge" down 2>/dev/null
                ip link delete "$bridge" 2>/dev/null || true
            done
            for veth in $(ip link show 2>/dev/null | grep -o 'veth-[^:]*'); do
                ip link delete "$veth" 2>/dev/null || true
            done
            log_info "‚úÖ Cleanup completed"
            ;;
        *)
            echo "Usage: $0 {create-vpc|create-subnet|list-vpcs|test|cleanup}"
            echo "  create-vpc <name> <cidr>"
            echo "  create-subnet <vpc> <name> <cidr> [type]"
            echo "  list-vpcs"
            echo "  test <vpc> <subnet1> <subnet2>"
            echo "  cleanup"
            ;;
    esac
}

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_error "This script must be run as root for network operations"
    exit 1
fi

main "$@"
EOF

chmod +x vpcctl
