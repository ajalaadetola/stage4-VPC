#!/bin/bash

# vpcctl - Linux VPC Manager
# Designed to meet specific networking requirements

set -euo pipefail

# Configuration
VPC_DIR="/tmp/vpc_configs"
LOG_FILE="/var/log/vpc/vpcctl.log"
LOCK_FILE="/tmp/vpcctl.lock"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Enhanced logging to meet requirements
init_log() {
    mkdir -p "$(dirname "$LOG_FILE")"
    if [[ ! -f "$LOG_FILE" ]]; then
        echo "=== VPC ACTIVITY LOG - Started at $(date) ===" > "$LOG_FILE"
        echo "=== All VPC activities will be logged here ===" >> "$LOG_FILE"
    fi
}

log_activity() {
    local action="$1"
    local resource="$2"
    local status="$3"
    local details="$4"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "$timestamp - ACTION: $action - RESOURCE: $resource - STATUS: $status - DETAILS: $details" >> "$LOG_FILE"
    
    # Also show in console with colors
    case "$status" in
        "SUCCESS") echo -e "${GREEN}[SUCCESS]${NC} $action - $resource: $details" ;;
        "FAILED") echo -e "${RED}[FAILED]${NC} $action - $resource: $details" ;;
        "BLOCKED") echo -e "${YELLOW}[BLOCKED]${NC} $action - $resource: $details" ;;
        *) echo -e "${BLUE}[INFO]${NC} $action - $resource: $details" ;;
    esac
}

# Requirement 1: Communication between subnets in same VPC
setup_intra_vpc_communication() {
    local vpc_name="$1"
    local vpc_cidr="$2"
    
    log_activity "SETUP_INTRA_VPC_COMM" "$vpc_name" "SUCCESS" "Enabled communication between subnets in VPC $vpc_cidr"
    
    # Enable proxy ARP for intra-VPC communication
    echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward >/dev/null
    local bridge_name="br_$vpc_name"
    echo 1 | sudo tee /proc/sys/net/ipv4/conf/$bridge_name/proxy_arp >/dev/null
}

# Requirement 2: Outbound access from public subnet
setup_public_subnet_nat() {
    local vpc_name="$1"
    local subnet_name="$2"
    local host_interface="${3:-eth0}"
    
    log_activity "SETUP_PUBLIC_NAT" "$vpc_name/$subnet_name" "SUCCESS" "Enabled outbound NAT via $host_interface"
    
    local vpc_cidr=$(get_vpc_config "$vpc_name" "CIDR")
    
    # Configure NAT for public subnet
    sudo iptables -t nat -A POSTROUTING -s "$vpc_cidr" -o "$host_interface" -j MASQUERADE
    sudo iptables -A FORWARD -i "br_$vpc_name" -o "$host_interface" -j ACCEPT
    sudo iptables -A FORWARD -i "$host_interface" -o "br_$vpc_name" -m state --state RELATED,ESTABLISHED -j ACCEPT
    
    # Store NAT configuration
    save_vpc_config "$vpc_name" "NAT_INTERFACE" "$host_interface"
    save_vpc_config "$vpc_name" "NAT_ENABLED" "true"
}

# Requirement 3: Outbound access from private subnet - BLOCKED
block_private_subnet_internet() {
    local vpc_name="$1"
    local subnet_name="$2"
    
    log_activity "BLOCK_PRIVATE_INTERNET" "$vpc_name/$subnet_name" "BLOCKED" "Blocked outbound internet access from private subnet"
    
    local ns_name=$(get_vpc_config "$vpc_name" "SUBNET_${subnet_name}_NS")
    
    # Block outbound traffic to non-RFC1918 addresses
    sudo ip netns exec "$ns_name" iptables -I OUTPUT -d 10.0.0.0/8 -j ACCEPT
    sudo ip netns exec "$ns_name" iptables -I OUTPUT -d 172.16.0.0/12 -j ACCEPT
    sudo ip netns exec "$ns_name" iptables -I OUTPUT -d 192.168.0.0/16 -j ACCEPT
    sudo ip netns exec "$ns_name" iptables -A OUTPUT -j DROP
    
    # Also block DNS to external servers (except for internal RFC1918)
    sudo ip netns exec "$ns_name" iptables -A OUTPUT -p udp --dport 53 -d 10.0.0.0/8 -j ACCEPT
    sudo ip netns exec "$ns_name" iptables -A OUTPUT -p udp --dport 53 -d 172.16.0.0/12 -j ACCEPT
    sudo ip netns exec "$ns_name" iptables -A OUTPUT -p udp --dport 53 -d 192.168.0.0/16 -j ACCEPT
    sudo ip netns exec "$ns_name" iptables -A OUTPUT -p udp --dport 53 -j DROP
}

# Requirement 4: Communication between different VPCs - BLOCKED by default
setup_inter_vpc_isolation() {
    local vpc1_name="$1"
    local vpc2_name="$2"
    
    log_activity "ENFORCE_VPC_ISOLATION" "$vpc1_name<->$vpc2_name" "BLOCKED" "VPCs are isolated by default (no peering)"
    
    # No action needed - isolation is the default state
    # Logging shows that we're maintaining isolation
}

# Requirement 5: Communication after peering - ALLOWED where configured
setup_vpc_peering() {
    local vpc1_name="$1"
    local vpc2_name="$2"
    
    log_activity "SETUP_VPC_PEERING" "$vpc1_name<->$vpc2_name" "SUCCESS" "Creating VPC peering connection"
    
    # Create veth pair for peering (with short names)
    local peer1="p_${vpc1_name:0:3}_${vpc2_name:0:3}"
    local peer2="p_${vpc2_name:0:3}_${vpc1_name:0:3}"
    
    # Clean up existing interfaces
    cleanup_existing_veth "$peer1"
    
    # Create peering connection
    sudo ip link add "$peer1" type veth peer name "$peer2"
    sudo ip link set "$peer1" master "br_$vpc1_name"
    sudo ip link set "$peer2" master "br_$vpc2_name"
    sudo ip link set "$peer1" up
    sudo ip link set "$peer2" up
    
    # Get CIDR blocks
    local vpc1_cidr=$(get_vpc_config "$vpc1_name" "CIDR")
    local vpc2_cidr=$(get_vpc_config "$vpc2_name" "CIDR")
    
    # Add routes explicitly (requirement: allowed where explicitly configured)
    local subnets1=$(get_vpc_config "$vpc1_name" "SUBNETS")
    IFS=',' read -ra subnet_array1 <<< "$subnets1"
    for subnet in "${subnet_array1[@]}"; do
        local ns_name=$(get_vpc_config "$vpc1_name" "SUBNET_${subnet}_NS")
        local gateway=$(get_vpc_config "$vpc1_name" "SUBNET_${subnet}_GATEWAY")
        if [[ -n "$ns_name" ]]; then
            sudo ip netns exec "$ns_name" ip route add "$vpc2_cidr" via "$gateway"
        fi
    done
    
    local subnets2=$(get_vpc_config "$vpc2_name" "SUBNETS")
    IFS=',' read -ra subnet_array2 <<< "$subnets2"
    for subnet in "${subnet_array2[@]}"; do
        local ns_name=$(get_vpc_config "$vpc2_name" "SUBNET_${subnet}_NS")
        local gateway=$(get_vpc_config "$vpc2_name" "SUBNET_${subnet}_GATEWAY")
        if [[ -n "$ns_name" ]]; then
            sudo ip netns exec "$ns_name" ip route add "$vpc1_cidr" via "$gateway"
        fi
    done
    
    log_activity "VPC_PEERING_ROUTES" "$vpc1_name<->$vpc2_name" "ALLOWED" "Added explicit routes for peered VPCs"
}

# Requirement 6: Policy enforcement - specific connections blocked
apply_network_policies() {
    local vpc_name="$1"
    local subnet_name="$2"
    local policy_file="${3:-}"
    
    local ns_name=$(get_vpc_config "$vpc_name" "SUBNET_${subnet_name}_NS")
    local subnet_type=$(get_vpc_config "$vpc_name" "SUBNET_${subnet_name}_TYPE")
    
    # Reset iptables to known state
    sudo ip netns exec "$ns_name" iptables -F
    sudo ip netns exec "$ns_name" iptables -X
    sudo ip netns exec "$ns_name" iptables -Z
    
    # Default policies
    sudo ip netns exec "$ns_name" iptables -P INPUT DROP
    sudo ip netns exec "$ns_name" iptables -P FORWARD DROP
    sudo ip netns exec "$ns_name" iptables -P OUTPUT ACCEPT
    
    # Allow loopback
    sudo ip netns exec "$ns_name" iptables -A INPUT -i lo -j ACCEPT
    sudo ip netns exec "$ns_name" iptables -A OUTPUT -o lo -j ACCEPT
    
    # Allow established connections
    sudo ip netns exec "$ns_name" iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    
    # Different policies based on subnet type
    if [[ "$subnet_type" == "public" ]]; then
        # Public subnet: allow SSH, HTTP, HTTPS
        sudo ip netns exec "$ns_name" iptables -A INPUT -p tcp --dport 22 -j ACCEPT
        sudo ip netns exec "$ns_name" iptables -A INPUT -p tcp --dport 80 -j ACCEPT
        sudo ip netns exec "$ns_name" iptables -A INPUT -p tcp --dport 443 -j ACCEPT
        log_activity "APPLY_POLICY" "$vpc_name/$subnet_name" "ALLOWED" "Public subnet: SSH, HTTP, HTTPS allowed"
        
    elif [[ "$subnet_type" == "private" ]]; then
        # Private subnet: only allow intra-VPC traffic
        local vpc_cidr=$(get_vpc_config "$vpc_name" "CIDR")
        sudo ip netns exec "$ns_name" iptables -A INPUT -s "$vpc_cidr" -j ACCEPT
        log_activity "APPLY_POLICY" "$vpc_name/$subnet_name" "RESTRICTED" "Private subnet: Only intra-VPC traffic allowed"
    fi
    
    # Apply custom policies from file if provided
    if [[ -n "$policy_file" && -f "$policy_file" ]]; then
        apply_custom_policies "$ns_name" "$policy_file"
    fi
    
    log_activity "POLICY_ENFORCEMENT" "$vpc_name/$subnet_name" "SUCCESS" "Network policies applied"
}

# Enhanced VPC creation meeting all requirements
create_vpc() {
    local vpc_name="$1"
    local cidr_block="$2"
    
    log_activity "CREATE_VPC" "$vpc_name" "STARTED" "Creating VPC with CIDR: $cidr_block"
    
    # Validate inputs
    if ! validate_cidr "$cidr_block"; then
        log_activity "CREATE_VPC" "$vpc_name" "FAILED" "Invalid CIDR: $cidr_block"
        return 1
    fi
    
    if vpc_exists "$vpc_name"; then
        log_activity "CREATE_VPC" "$vpc_name" "FAILED" "VPC already exists"
        return 1
    fi
    
    # Create bridge
    local bridge_name="br_$vpc_name"
    sudo ip link add "$bridge_name" type bridge
    sudo ip link set "$bridge_name" up
    
    # Assign gateway IP
    local gateway_ip="${cidr_block%.*}.1"
    sudo ip addr add "$gateway_ip/$(echo $cidr_block | cut -d'/' -f2)" dev "$bridge_name"
    
    # Store configuration
    save_vpc_config "$vpc_name" "CIDR" "$cidr_block"
    save_vpc_config "$vpc_name" "BRIDGE" "$bridge_name"
    save_vpc_config "$vpc_name" "GATEWAY" "$gateway_ip"
    save_vpc_config "$vpc_name" "SUBNETS" ""
    save_vpc_config "$vpc_name" "CREATED_AT" "$(date -Iseconds)"
    
    # Setup intra-VPC communication (Requirement 1)
    setup_intra_vpc_communication "$vpc_name" "$cidr_block"
    
    log_activity "CREATE_VPC" "$vpc_name" "SUCCESS" "VPC created with CIDR $cidr_block, intra-VPC communication enabled"
}

# Enhanced subnet creation with proper isolation
create_subnet() {
    local vpc_name="$1"
    local subnet_name="$2"
    local subnet_cidr="$3"
    local subnet_type="${4:-private}"
    
    log_activity "CREATE_SUBNET" "$vpc_name/$subnet_name" "STARTED" "Creating $subnet_type subnet with $subnet_cidr"
    
    if ! vpc_exists "$vpc_name"; then
        log_activity "CREATE_SUBNET" "$vpc_name/$subnet_name" "FAILED" "VPC not found"
        return 1
    fi
    
    # Create namespace
    local ns_name="ns-${vpc_name}_${subnet_name}"
    sudo ip netns add "$ns_name"
    sudo ip netns exec "$ns_name" ip link set lo up
    
    # Create veth pair
    local veth_host="veth_${subnet_name}_h"
    local veth_ns="veth_${subnet_name}_n"
    
    sudo ip link add "$veth_host" type veth peer name "$veth_ns"
    sudo ip link set "$veth_ns" netns "$ns_name"
    
    # Connect to bridge
    local bridge_name=$(get_vpc_config "$vpc_name" "BRIDGE")
    sudo ip link set "$veth_host" master "$bridge_name"
    sudo ip link set "$veth_host" up
    sudo ip netns exec "$ns_name" ip link set "$veth_ns" up
    
    # Assign IP
    local namespace_ip="${subnet_cidr%.*}.2"
    sudo ip netns exec "$ns_name" ip addr add "$namespace_ip/24" dev "$veth_ns"
    
    # Add gateway IP to bridge if needed
    local gateway_ip="${subnet_cidr%.*}.1"
    if ! ip addr show "$bridge_name" | grep -q "$gateway_ip"; then
        sudo ip addr add "$gateway_ip/24" dev "$bridge_name"
    fi
    
    # Set default route
    sudo ip netns exec "$ns_name" ip route add default via "$gateway_ip"
    
    # Store configuration
    local current_subs=$(get_vpc_config "$vpc_name" "SUBNETS")
    if [[ -z "$current_subs" ]]; then
        save_vpc_config "$vpc_name" "SUBNETS" "$subnet_name"
    else
        save_vpc_config "$vpc_name" "SUBNETS" "$current_subs,$subnet_name"
    fi
    
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_NS" "$ns_name"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_CIDR" "$subnet_cidr"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_TYPE" "$subnet_type"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_IP" "$namespace_ip"
    
    # Apply appropriate policies based on subnet type
    apply_network_policies "$vpc_name" "$subnet_name"
    
    # Setup outbound access based on subnet type
    if [[ "$subnet_type" == "public" ]]; then
        log_activity "SUBNET_CREATED" "$vpc_name/$subnet_name" "SUCCESS" "Public subnet created - outbound internet access enabled"
    else
        block_private_subnet_internet "$vpc_name" "$subnet_name"
        log_activity "SUBNET_CREATED" "$vpc_name/$subnet_name" "SUCCESS" "Private subnet created - outbound internet blocked"
    fi
}

# Test functions to verify requirements
test_connectivity() {
    local vpc_name="$1"
    
    log_activity "TEST_CONNECTIVITY" "$vpc_name" "STARTED" "Testing all connectivity requirements"
    
    local subnets=$(get_vpc_config "$vpc_name" "SUBNETS")
    IFS=',' read -ra subnet_array <<< "$subnets"
    
    # Test intra-VPC communication (Requirement 1)
    if [[ ${#subnet_array[@]} -ge 2 ]]; then
        local subnet1="${subnet_array[0]}"
        local subnet2="${subnet_array[1]}"
        local ip1=$(get_vpc_config "$vpc_name" "SUBNET_${subnet1}_IP")
        local ip2=$(get_vpc_config "$vpc_name" "SUBNET_${subnet2}_IP")
        
        if sudo ip netns exec "ns-${vpc_name}_${subnet1}" ping -c 1 -W 1 "$ip2" &>/dev/null; then
            log_activity "TEST_INTRA_VPC" "$vpc_name" "SUCCESS" "Subnet $subnet1 can reach $subnet2"
        else
            log_activity "TEST_INTRA_VPC" "$vpc_name" "FAILED" "Subnet $subnet1 cannot reach $subnet2"
        fi
    fi
    
    # Test outbound access from public subnet (Requirement 2)
    for subnet in "${subnet_array[@]}"; do
        local subnet_type=$(get_vpc_config "$vpc_name" "SUBNET_${subnet}_TYPE")
        if [[ "$subnet_type" == "public" ]]; then
            if sudo ip netns exec "ns-${vpc_name}_${subnet}" ping -c 1 -W 1 8.8.8.8 &>/dev/null; then
                log_activity "TEST_PUBLIC_OUTBOUND" "$vpc_name/$subnet" "SUCCESS" "Public subnet has outbound internet access"
            else
                log_activity "TEST_PUBLIC_OUTBOUND" "$vpc_name/$subnet" "FAILED" "Public subnet no outbound internet access"
            fi
        else
            if ! sudo ip netns exec "ns-${vpc_name}_${subnet}" ping -c 1 -W 1 8.8.8.8 &>/dev/null; then
                log_activity "TEST_PRIVATE_BLOCKED" "$vpc_name/$subnet" "SUCCESS" "Private subnet internet access properly blocked"
            else
                log_activity "TEST_PRIVATE_BLOCKED" "$vpc_name/$subnet" "FAILED" "Private subnet has internet access (should be blocked)"
            fi
        fi
    done
    
    log_activity "TEST_CONNECTIVITY" "$vpc_name" "COMPLETED" "All connectivity tests finished"
}

# Cleanup with comprehensive logging
cleanup_all() {
    log_activity "CLEANUP" "ALL" "STARTED" "Beginning complete VPC cleanup"
    
    # Remove all VPCs
    for config_file in "$VPC_DIR"/*.conf 2>/dev/null; do
        local vpc_name=$(basename "$config_file" .conf)
        delete_vpc "$vpc_name" "true"
    done
    
    # Cleanup network namespaces
    for ns in $(ip netns list | cut -d' ' -f1); do
        sudo ip netns delete "$ns"
        log_activity "CLEANUP_NAMESPACE" "$ns" "SUCCESS" "Removed namespace"
    done
    
    # Cleanup bridges
    for bridge in $(ip link show type bridge | grep -o 'br_[^:]*'); do
        sudo ip link delete "$bridge"
        log_activity "CLEANUP_BRIDGE" "$bridge" "SUCCESS" "Removed bridge"
    done
    
    # Cleanup iptables rules
    sudo iptables -t nat -F
    sudo iptables -F FORWARD
    
    log_activity "CLEANUP" "ALL" "SUCCESS" "Complete VPC cleanup finished"
    echo "=== VPC ACTIVITY LOG - Cleanup completed at $(date) ===" >> "$LOG_FILE"
}

# Main function
main() {
    init_log
    
    case "${1:-}" in
        create-vpc)
            [[ $# -eq 3 ]] || { echo "Usage: create-vpc <name> <cidr>"; exit 1; }
            create_vpc "$2" "$3"
            ;;
        create-subnet)
            [[ $# -ge 4 ]] || { echo "Usage: create-subnet <vpc> <name> <cidr> [type]"; exit 1; }
            create_subnet "$2" "$3" "$4" "${5:-private}"
            ;;
        setup-nat)
            [[ $# -ge 3 ]] || { echo "Usage: setup-nat <vpc> <subnet> [interface]"; exit 1; }
            setup_public_subnet_nat "$2" "$3" "${4:-eth0}"
            ;;
        setup-peering)
            [[ $# -eq 3 ]] || { echo "Usage: setup-peering <vpc1> <vpc2>"; exit 1; }
            setup_vpc_peering "$2" "$3"
            ;;
        test)
            [[ $# -eq 2 ]] || { echo "Usage: test <vpc>"; exit 1; }
            test_connectivity "$2"
            ;;
        cleanup)
            cleanup_all
            ;;
        show-logs)
            cat "$LOG_FILE"
            ;;
        *)
            echo "Usage: $0 {create-vpc|create-subnet|setup-nat|setup-peering|test|cleanup|show-logs}"
            exit 1
            ;;
    esac
}

# Helper functions (simplified versions)
validate_cidr() { [[ "$1" =~ ^[0-9.]+/[0-9]+$ ]]; }
vpc_exists() { [[ -f "/tmp/vpc_configs/$1.conf" ]]; }
get_vpc_config() { grep "^$2=" "/tmp/vpc_configs/$1.conf" 2>/dev/null | cut -d'=' -f2-; }
save_vpc_config() { 
    mkdir -p "/tmp/vpc_configs";
    local config_file="/tmp/vpc_configs/$1.conf";
    grep -v "^$2=" "$config_file" 2>/dev/null > "${config_file}.tmp" || true;
    echo "$2=$3" >> "${config_file}.tmp";
    mv "${config_file}.tmp" "$config_file";
}
cleanup_existing_veth() { ip link delete "$1" 2>/dev/null || true; }
apply_custom_policies() { echo "Custom policies would be applied here"; }

# Run as root check
[[ $EUID -eq 0 ]] || { echo "This script must be run as root"; exit 1; }

main "$@"
