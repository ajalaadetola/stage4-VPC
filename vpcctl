#!/bin/bash

# vpcctl - Linux VPC Manager
# Complete implementation with all requirements

set -e

# Configuration
VPC_DIR="/tmp/vpc_configs"
LOG_FILE="/var/log/vpc/vpcctl.log"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Enhanced logging
init_log() {
    mkdir -p "$(dirname "$LOG_FILE")"
    if [[ ! -f "$LOG_FILE" ]]; then
        echo "=== VPC ACTIVITY LOG - Started at $(date) ===" > "$LOG_FILE"
        echo "=== All VPC activities will be logged here ===" >> "$LOG_FILE"
    fi
}

log_activity() {
    local action="$1"
    local resource="$2"
    local status="$3"
    local details="$4"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "$timestamp - ACTION: $action - RESOURCE: $resource - STATUS: $status - DETAILS: $details" >> "$LOG_FILE"
    
    case "$status" in
        "SUCCESS") echo -e "${GREEN}[SUCCESS]${NC} $action - $resource: $details" ;;
        "FAILED") echo -e "${RED}[FAILED]${NC} $action - $resource: $details" ;;
        "BLOCKED") echo -e "${YELLOW}[BLOCKED]${NC} $action - $resource: $details" ;;
        *) echo -e "${BLUE}[INFO]${NC} $action - $resource: $details" ;;
    esac
}

# Validation functions
validate_cidr() {
    local cidr="$1"
    if ! echo "$cidr" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$'; then
        log_activity "VALIDATE_CIDR" "$cidr" "FAILED" "Invalid CIDR format"
        return 1
    fi
    return 0
}

validate_vpc_name() {
    local name="$1"
    if ! echo "$name" | grep -Eq '^[a-zA-Z0-9_-]+$'; then
        log_activity "VALIDATE_VPC_NAME" "$name" "FAILED" "Invalid VPC name"
        return 1
    fi
    return 0
}

# Command execution
run_cmd() {
    local cmd="$1"
    local check="${2:-true}"
    
    if output=$(eval "$cmd" 2>&1); then
        if [ -n "$output" ] && [ "$output" != "RTNETLINK answers: File exists" ]; then
            return 0
        fi
        return 0
    else
        local result=$?
        if [ "$check" = "true" ]; then
            log_activity "COMMAND_FAILED" "$cmd" "FAILED" "Exit code: $result - $output"
            return $result
        else
            return $result
        fi
    fi
}

# Network namespace operations
namespace_exists() {
    ip netns list 2>/dev/null | grep -q "$1"
}

create_namespace() {
    local ns="$1"
    if ! namespace_exists "$ns"; then
        log_activity "CREATE_NAMESPACE" "$ns" "SUCCESS" "Creating network namespace"
        run_cmd "ip netns add $ns"
        run_cmd "ip netns exec $ns ip link set lo up"
    else
        log_activity "CREATE_NAMESPACE" "$ns" "EXISTS" "Namespace already exists"
    fi
}

delete_namespace() {
    local ns="$1"
    if namespace_exists "$ns"; then
        log_activity "DELETE_NAMESPACE" "$ns" "SUCCESS" "Deleting namespace"
        run_cmd "ip netns delete $ns" "false"
    fi
}

# Bridge operations
bridge_exists() {
    ip link show "$1" 2>/dev/null | grep -q "$1"
}

create_bridge() {
    local bridge="$1"
    if ! bridge_exists "$bridge"; then
        log_activity "CREATE_BRIDGE" "$bridge" "SUCCESS" "Creating bridge"
        run_cmd "ip link add $bridge type bridge"
        run_cmd "ip link set $bridge up"
    else
        log_activity "CREATE_BRIDGE" "$bridge" "EXISTS" "Bridge already exists"
    fi
}

delete_bridge() {
    local bridge="$1"
    if bridge_exists "$bridge"; then
        log_activity "DELETE_BRIDGE" "$bridge" "SUCCESS" "Deleting bridge"
        run_cmd "ip link set $bridge down" "false"
        run_cmd "ip link delete $bridge type bridge" "false"
    fi
}

# VPC configuration management
get_vpc_config_path() {
    echo "$VPC_DIR/$1.conf"
}

vpc_exists() {
    [ -f "$(get_vpc_config_path "$1")" ]
}

save_vpc_config() {
    local vpc_name="$1"
    local key="$2"
    local value="$3"
    
    local config_file="$(get_vpc_config_path "$vpc_name")"
    mkdir -p "$VPC_DIR"
    
    if [ ! -f "$config_file" ]; then
        touch "$config_file"
    fi
    
    if grep -q "^$key=" "$config_file" 2>/dev/null; then
        sed -i "s|^$key=.*|$key=$value|" "$config_file"
    else
        echo "$key=$value" >> "$config_file"
    fi
}

get_vpc_config() {
    local vpc_name="$1"
    local key="$2"
    local config_file="$(get_vpc_config_path "$vpc_name")"
    
    if [ -f "$config_file" ]; then
        grep "^$key=" "$config_file" | cut -d'=' -f2-
    fi
}

# Cleanup functions
cleanup_existing_veth() {
    local veth_name="$1"
    if ip link show "$veth_name" >/dev/null 2>&1; then
        log_activity "CLEANUP_VETH" "$veth_name" "SUCCESS" "Cleaning up existing veth"
        run_cmd "ip link delete $veth_name" "false"
    fi
}

# Requirement 1: Communication between subnets in same VPC
setup_intra_vpc_communication() {
    local vpc_name="$1"
    local vpc_cidr="$2"
    
    log_activity "SETUP_INTRA_VPC" "$vpc_name" "SUCCESS" "Enabling intra-VPC communication"
    
    # Enable proxy ARP for intra-VPC communication
    echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward >/dev/null
    local bridge_name="br_$vpc_name"
    echo 1 | sudo tee /proc/sys/net/ipv4/conf/$bridge_name/proxy_arp >/dev/null
}

# Requirement 2: Outbound access from public subnet
setup_public_subnet_nat() {
    local vpc_name="$1"
    local subnet_name="$2"
    local host_interface="${3:-eth0}"
    
    log_activity "SETUP_NAT" "$vpc_name/$subnet_name" "SUCCESS" "Setting up NAT via $host_interface"
    
    local vpc_cidr=$(get_vpc_config "$vpc_name" "CIDR")
    
    # Configure NAT for public subnet
    run_cmd "iptables -t nat -A POSTROUTING -s $vpc_cidr -o $host_interface -j MASQUERADE"
    run_cmd "iptables -A FORWARD -i br_$vpc_name -o $host_interface -j ACCEPT"
    run_cmd "iptables -A FORWARD -i $host_interface -o br_$vpc_name -m state --state RELATED,ESTABLISHED -j ACCEPT"
    
    save_vpc_config "$vpc_name" "NAT_INTERFACE" "$host_interface"
    save_vpc_config "$vpc_name" "NAT_ENABLED" "true"
}

# Requirement 3: Outbound access from private subnet - BLOCKED
block_private_subnet_internet() {
    local vpc_name="$1"
    local subnet_name="$2"
    
    log_activity "BLOCK_INTERNET" "$vpc_name/$subnet_name" "BLOCKED" "Blocking internet access from private subnet"
    
    local ns_name=$(get_vpc_config "$vpc_name" "SUBNET_${subnet_name}_NS")
    
    # Block outbound traffic to external IPs
    run_cmd "ip netns exec $ns_name iptables -I OUTPUT -d 10.0.0.0/8 -j ACCEPT"
    run_cmd "ip netns exec $ns_name iptables -I OUTPUT -d 172.16.0.0/12 -j ACCEPT"
    run_cmd "ip netns exec $ns_name iptables -I OUTPUT -d 192.168.0.0/16 -j ACCEPT"
    run_cmd "ip netns exec $ns_name iptables -A OUTPUT -j DROP"
}

# Requirement 5: Communication after peering - ALLOWED where configured
setup_vpc_peering() {
    local vpc1_name="$1"
    local vpc2_name="$2"
    
    log_activity "SETUP_PEERING" "$vpc1_name<->$vpc2_name" "STARTED" "Setting up VPC peering"
    
    # Create short interface names
    local peer1="p_${vpc1_name:0:3}_${vpc2_name:0:3}"
    local peer2="p_${vpc2_name:0:3}_${vpc1_name:0:3}"
    
    # Clean up existing interfaces
    cleanup_existing_veth "$peer1"
    
    # Create peering connection
    run_cmd "ip link add $peer1 type veth peer name $peer2"
    run_cmd "ip link set $peer1 master br_$vpc1_name"
    run_cmd "ip link set $peer2 master br_$vpc2_name"
    run_cmd "ip link set $peer1 up"
    run_cmd "ip link set $peer2 up"
    
    # Get CIDR blocks
    local vpc1_cidr=$(get_vpc_config "$vpc1_name" "CIDR")
    local vpc2_cidr=$(get_vpc_config "$vpc2_name" "CIDR")
    
    # Add routes to all subnets in both VPCs
    local subnets1=$(get_vpc_config "$vpc1_name" "SUBNETS")
    if [ -n "$subnets1" ]; then
        IFS=',' read -ra subnet_array1 <<< "$subnets1"
        for subnet in "${subnet_array1[@]}"; do
            local ns_name=$(get_vpc_config "$vpc1_name" "SUBNET_${subnet}_NS")
            local gateway=$(get_vpc_config "$vpc1_name" "SUBNET_${subnet}_GATEWAY")
            if [ -n "$ns_name" ]; then
                run_cmd "ip netns exec $ns_name ip route add $vpc2_cidr via $gateway" "false"
            fi
        done
    fi
    
    local subnets2=$(get_vpc_config "$vpc2_name" "SUBNETS")
    if [ -n "$subnets2" ]; then
        IFS=',' read -ra subnet_array2 <<< "$subnets2"
        for subnet in "${subnet_array2[@]}"; do
            local ns_name=$(get_vpc_config "$vpc2_name" "SUBNET_${subnet}_NS")
            local gateway=$(get_vpc_config "$vpc2_name" "SUBNET_${subnet}_GATEWAY")
            if [ -n "$ns_name" ]; then
                run_cmd "ip netns exec $ns_name ip route add $vpc1_cidr via $gateway" "false"
            fi
        done
    fi
    
    log_activity "SETUP_PEERING" "$vpc1_name<->$vpc2_name" "SUCCESS" "VPC peering established with routes"
}

# Enhanced VPC creation
create_vpc() {
    local vpc_name="$1"
    local cidr_block="$2"
    
    log_activity "CREATE_VPC" "$vpc_name" "STARTED" "Creating VPC with CIDR: $cidr_block"
    
    # Validate inputs
    validate_vpc_name "$vpc_name" || return 1
    validate_cidr "$cidr_block" || return 1
    
    if vpc_exists "$vpc_name"; then
        log_activity "CREATE_VPC" "$vpc_name" "FAILED" "VPC already exists"
        return 1
    fi
    
    # Create bridge
    local bridge_name="br_$vpc_name"
    create_bridge "$bridge_name"
    
    # Assign gateway IP
    local gateway_ip="${cidr_block%.*}.1"
    run_cmd "ip addr add $gateway_ip/$(echo $cidr_block | cut -d'/' -f2) dev $bridge_name" "false"
    
    # Store configuration
    save_vpc_config "$vpc_name" "CIDR" "$cidr_block"
    save_vpc_config "$vpc_name" "BRIDGE" "$bridge_name"
    save_vpc_config "$vpc_name" "GATEWAY" "$gateway_ip"
    save_vpc_config "$vpc_name" "SUBNETS" ""
    
    # Setup intra-VPC communication
    setup_intra_vpc_communication "$vpc_name" "$cidr_block"
    
    log_activity "CREATE_VPC" "$vpc_name" "SUCCESS" "VPC created with CIDR $cidr_block"
}

# Enhanced subnet creation
create_subnet() {
    local vpc_name="$1"
    local subnet_name="$2"
    local subnet_cidr="$3"
    local subnet_type="${4:-private}"
    
    log_activity "CREATE_SUBNET" "$vpc_name/$subnet_name" "STARTED" "Creating $subnet_type subnet"
    
    if ! vpc_exists "$vpc_name"; then
        log_activity "CREATE_SUBNET" "$vpc_name/$subnet_name" "FAILED" "VPC not found"
        return 1
    fi
    
    validate_cidr "$subnet_cidr" || return 1
    
    # Create namespace
    local ns_name="ns-${vpc_name}_${subnet_name}"
    if namespace_exists "$ns_name"; then
        delete_namespace "$ns_name"
    fi
    create_namespace "$ns_name"
    
    # Create veth pair
    local veth_host="veth_${subnet_name}_h"
    local veth_ns="veth_${subnet_name}_n"
    cleanup_existing_veth "$veth_host"
    
    run_cmd "ip link add $veth_host type veth peer name $veth_ns"
    run_cmd "ip link set $veth_ns netns $ns_name"
    
    # Connect to bridge
    local bridge_name=$(get_vpc_config "$vpc_name" "BRIDGE")
    run_cmd "ip link set $veth_host master $bridge_name"
    run_cmd "ip link set $veth_host up"
    run_cmd "ip netns exec $ns_name ip link set $veth_ns up"
    
    # Assign IP
    local namespace_ip="${subnet_cidr%.*}.2"
    run_cmd "ip netns exec $ns_name ip addr add $namespace_ip/24 dev $veth_ns"
    
    # Add gateway IP to bridge if needed
    local gateway_ip="${subnet_cidr%.*}.1"
    if ! ip addr show "$bridge_name" | grep -q "$gateway_ip"; then
        run_cmd "ip addr add $gateway_ip/24 dev $bridge_name" "false"
    fi
    
    # Set default route
    run_cmd "ip netns exec $ns_name ip route add default via $gateway_ip"
    
    # Store configuration
    local current_subs=$(get_vpc_config "$vpc_name" "SUBNETS")
    if [ -z "$current_subs" ]; then
        save_vpc_config "$vpc_name" "SUBNETS" "$subnet_name"
    else
        save_vpc_config "$vpc_name" "SUBNETS" "$current_subs,$subnet_name"
    fi
    
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_NS" "$ns_name"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_CIDR" "$subnet_cidr"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_TYPE" "$subnet_type"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_VETH_HOST" "$veth_host"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_VETH_NS" "$veth_ns"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_IP" "$namespace_ip"
    save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_GATEWAY" "$gateway_ip"
    
    # Apply policies based on subnet type
    if [[ "$subnet_type" == "private" ]]; then
        block_private_subnet_internet "$vpc_name" "$subnet_name"
    fi
    
    log_activity "CREATE_SUBNET" "$vpc_name/$subnet_name" "SUCCESS" "$subnet_type subnet created"
}

delete_subnet() {
    local vpc_name="$1"
    local subnet_name="$2"
    
    log_activity "DELETE_SUBNET" "$vpc_name/$subnet_name" "STARTED" "Deleting subnet"
    
    if ! vpc_exists "$vpc_name"; then
        log_activity "DELETE_SUBNET" "$vpc_name/$subnet_name" "FAILED" "VPC not found"
        return 1
    fi
    
    local ns_name=$(get_vpc_config "$vpc_name" "SUBNET_${subnet_name}_NS")
    local veth_host=$(get_vpc_config "$vpc_name" "SUBNET_${subnet_name}_VETH_HOST")
    
    # Delete namespace
    delete_namespace "$ns_name"
    
    # Remove veth host interface
    cleanup_existing_veth "$veth_host"
    
    # Remove subnet from configuration
    local current_subs=$(get_vpc_config "$vpc_name" "SUBNETS")
    local new_subs=$(echo "$current_subs" | sed "s/,$subnet_name//g" | sed "s/^$subnet_name,//" | sed "s/^$subnet_name$//")
    save_vpc_config "$vpc_name" "SUBNETS" "$new_subs"
    
    # Remove subnet-specific configs
    for key in NS CIDR TYPE VETH_HOST VETH_NS IP GATEWAY; do
        save_vpc_config "$vpc_name" "SUBNET_${subnet_name}_${key}" ""
    done
    
    log_activity "DELETE_SUBNET" "$vpc_name/$subnet_name" "SUCCESS" "Subnet deleted"
}

delete_vpc() {
    local vpc_name="$1"
    
    log_activity "DELETE_VPC" "$vpc_name" "STARTED" "Deleting VPC and all subnets"
    
    if ! vpc_exists "$vpc_name"; then
        log_activity "DELETE_VPC" "$vpc_name" "FAILED" "VPC not found"
        return 1
    fi
    
    # Delete all subnets first
    local subnets=$(get_vpc_config "$vpc_name" "SUBNETS")
    if [ -n "$subnets" ]; then
        IFS=',' read -ra subnet_array <<< "$subnets"
        for subnet in "${subnet_array[@]}"; do
            delete_subnet "$vpc_name" "$subnet"
        done
    fi
    
    # Delete bridge
    local bridge_name=$(get_vpc_config "$vpc_name" "BRIDGE")
    delete_bridge "$bridge_name"
    
    # Remove configuration
    rm -f "$(get_vpc_config_path "$vpc_name")"
    
    log_activity "DELETE_VPC" "$vpc_name" "SUCCESS" "VPC deleted"
}

# FIXED cleanup_all function
cleanup_all() {
    log_activity "CLEANUP" "ALL" "STARTED" "Beginning complete VPC cleanup"
    
    # Remove all VPCs - CORRECTED SYNTAX
    if [[ -d "$VPC_DIR" ]]; then
        for config_file in "$VPC_DIR"/*.conf; do
            [[ -f "$config_file" ]] || continue  # Skip if no .conf files
            local vpc_name=$(basename "$config_file" .conf)
            delete_vpc "$vpc_name"
        done
    fi
    
    # Cleanup network namespaces
    for ns in $(ip netns list | cut -d' ' -f1); do
        sudo ip netns delete "$ns" 2>/dev/null || true
        log_activity "CLEANUP_NAMESPACE" "$ns" "SUCCESS" "Removed namespace"
    done
    
    # Cleanup bridges
    for bridge in $(ip link show type bridge 2>/dev/null | grep -o 'br_[^:]*' || true); do
        sudo ip link delete "$bridge" 2>/dev/null || true
        log_activity "CLEANUP_BRIDGE" "$bridge" "SUCCESS" "Removed bridge"
    done
    
    # Cleanup iptables rules
    sudo iptables -t nat -F 2>/dev/null || true
    sudo iptables -F FORWARD 2>/dev/null || true
    
    log_activity "CLEANUP" "ALL" "SUCCESS" "Complete VPC cleanup finished"
    echo "=== VPC ACTIVITY LOG - Cleanup completed at $(date) ===" >> "$LOG_FILE"
}

list_vpcs() {
    log_activity "LIST_VPCS" "ALL" "INFO" "Listing all VPCs"
    
    if [ ! -d "$VPC_DIR" ] || [ -z "$(ls -A "$VPC_DIR" 2>/dev/null)" ]; then
        echo "No VPCs found"
        return
    fi
    
    for config_file in "$VPC_DIR"/*.conf; do
        local vpc_name=$(basename "$config_file" .conf)
        local cidr=$(get_vpc_config "$vpc_name" "CIDR")
        local bridge=$(get_vpc_config "$vpc_name" "BRIDGE")
        local subnets=$(get_vpc_config "$vpc_name" "SUBNETS")
        
        echo ""
        echo "VPC: $vpc_name"
        echo "  CIDR: $cidr"
        echo "  Bridge: $bridge"
        echo "  Subnets: ${subnets:-None}"
        
        if [ -n "$subnets" ]; then
            IFS=',' read -ra subnet_array <<< "$subnets"
            for subnet in "${subnet_array[@]}"; do
                local subnet_cidr=$(get_vpc_config "$vpc_name" "SUBNET_${subnet}_CIDR")
                local subnet_type=$(get_vpc_config "$vpc_name" "SUBNET_${subnet}_TYPE")
                echo "    - $subnet: $subnet_cidr ($subnet_type)"
            done
        fi
    done
}

exec_in_subnet() {
    local vpc_name="$1"
    local subnet_name="$2"
    local command="$3"
    
    log_activity "EXEC_IN_SUBNET" "$vpc_name/$subnet_name" "INFO" "Executing: $command"
    
    if ! vpc_exists "$vpc_name"; then
        log_activity "EXEC_IN_SUBNET" "$vpc_name/$subnet_name" "FAILED" "VPC not found"
        return 1
    fi
    
    local ns_name=$(get_vpc_config "$vpc_name" "SUBNET_${subnet_name}_NS")
    if [ -z "$ns_name" ]; then
        log_activity "EXEC_IN_SUBNET" "$vpc_name/$subnet_name" "FAILED" "Subnet not found"
        return 1
    fi
    
    run_cmd "ip netns exec $ns_name $command"
}

show_logs() {
    if [ -f "$LOG_FILE" ]; then
        cat "$LOG_FILE"
    else
        echo "No log file found"
    fi
}

# Main CLI handler
main() {
    init_log
    
    if [ $# -lt 1 ]; then
        echo "Usage: $0 <command> [arguments]"
        echo "Commands: create-vpc, delete-vpc, create-subnet, delete-subnet, list-vpcs, setup-nat, setup-peering, exec, cleanup, show-logs"
        exit 1
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        create-vpc)
            if [ $# -lt 2 ]; then
                echo "Usage: create-vpc <name> <cidr>"
                exit 1
            fi
            create_vpc "$1" "$2"
            ;;
        delete-vpc)
            if [ $# -lt 1 ]; then
                echo "Usage: delete-vpc <name>"
                exit 1
            fi
            delete_vpc "$1"
            ;;
        create-subnet)
            if [ $# -lt 3 ]; then
                echo "Usage: create-subnet <vpc> <name> <cidr> [type]"
                exit 1
            fi
            create_subnet "$1" "$2" "$3" "$4"
            ;;
        delete-subnet)
            if [ $# -lt 2 ]; then
                echo "Usage: delete-subnet <vpc> <name>"
                exit 1
            fi
            delete_subnet "$1" "$2"
            ;;
        list-vpcs)
            list_vpcs
            ;;
        setup-nat)
            if [ $# -lt 2 ]; then
                echo "Usage: setup-nat <vpc> <subnet> [interface]"
                exit 1
            fi
            setup_public_subnet_nat "$1" "$2" "$3"
            ;;
        setup-peering)
            if [ $# -lt 2 ]; then
                echo "Usage: setup-peering <vpc1> <vpc2>"
                exit 1
            fi
            setup_vpc_peering "$1" "$2"
            ;;
        exec)
            if [ $# -lt 3 ]; then
                echo "Usage: exec <vpc> <subnet> <command>"
                exit 1
            fi
            exec_in_subnet "$1" "$2" "$3"
            ;;
        cleanup)
            cleanup_all
            ;;
        show-logs)
            show_logs
            ;;
        *)
            echo "Unknown command: $command"
            exit 1
            ;;
    esac
}

# Check if running as root for most operations
if [ "$1" != "list-vpcs" ] && [ "$1" != "show-logs" ] && [ "$EUID" -ne 0 ]; then
    echo "This script must be run as root for network operations"
    exit 1
fi

main "$@"
