# Create a backup of the current vpcctl
cp vpcctl vpcctl.backup

# Create a fixed vpcctl with better error handling
cat > vpcctl << 'EOF'
#!/bin/bash

# vpcctl - Linux VPC Manager
# Fixed version with better veth handling

set -e

# Configuration
VPC_DIR="/tmp/vpc_configs"
LOG_FILE="logs/vpc-demo.log"
LOG_PREFIX="vpcctl"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_to_file() {
    mkdir -p "$(dirname "$LOG_FILE")"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $*" >> "$LOG_FILE"
}

log_info() {
    local message="$*"
    echo -e "${GREEN}[INFO]${NC} $([ -n "$VPC_NAME" ] && echo "[$VPC_NAME] ")$message"
    log_to_file "[INFO] $([ -n "$VPC_NAME" ] && echo "[$VPC_NAME] ")$message"
}

log_warn() {
    local message="$*"
    echo -e "${YELLOW}[WARN]${NC} $([ -n "$VPC_NAME" ] && echo "[$VPC_NAME] ")$message"
    log_to_file "[WARN] $([ -n "$VPC_NAME" ] && echo "[$VPC_NAME] ")$message"
}

log_error() {
    local message="$*"
    echo -e "${RED}[ERROR]${NC} $([ -n "$VPC_NAME" ] && echo "[$VPC_NAME] ")$message"
    log_to_file "[ERROR] $([ -n "$VPC_NAME" ] && echo "[$VPC_NAME] ")$message"
}

log_debug() {
    local message="$*"
    echo -e "${BLUE}[DEBUG]${NC} $([ -n "$VPC_NAME" ] && echo "[$VPC_NAME] ")$message"
    log_to_file "[DEBUG] $([ -n "$VPC_NAME" ] && echo "[$VPC_NAME] ")$message"
}

# Initialize log file
init_log() {
    mkdir -p "$(dirname "$LOG_FILE")"
    echo "=== VPC DEMO LOG - Started at $(date) ===" > "$LOG_FILE"
}

# Command execution with better error handling
run_cmd() {
    local cmd="$1"
    local check="${2:-true}"
    
    log_debug "Executing: $cmd"
    
    # Use a different approach for command execution
    if bash -c "$cmd" 2>&1; then
        return 0
    else
        local result=$?
        if [ "$check" = "true" ]; then
            log_error "Command failed: $cmd (exit code: $result)"
            return $result
        else
            return $result
        fi
    fi
}

# Network namespace operations
namespace_exists() {
    ip netns list | grep -q "$1" 2>/dev/null
}

create_namespace() {
    local ns="$1"
    if ! namespace_exists "$ns"; then
        log_info "Creating network namespace: $ns"
        run_cmd "ip netns add '$ns'"
    else
        log_warn "Namespace $ns already exists"
    fi
}

delete_namespace() {
    local ns="$1"
    if namespace_exists "$ns"; then
        log_info "Deleting network namespace: $ns"
        run_cmd "ip netns delete '$ns'" "false"
    fi
}

# Bridge operations
bridge_exists() {
    ip link show "$1" 2>/dev/null | grep -q "$1"
}

create_bridge() {
    local bridge="$1"
    if ! bridge_exists "$bridge"; then
        log_info "Creating bridge: $bridge"
        run_cmd "ip link add '$bridge' type bridge"
        run_cmd "ip link set '$bridge' up"
    else
        log_warn "Bridge $bridge already exists"
    fi
}

# VPC configuration management
get_vpc_config_path() {
    echo "$VPC_DIR/$1.conf"
}

vpc_exists() {
    [ -f "$(get_vpc_config_path "$1")" ]
}

# Core VPC operations - SIMPLIFIED VERSION
create_vpc() {
    local vpc_name="$1"
    local cidr_block="$2"
    
    log_info "ðŸš€ Creating VPC: $vpc_name with CIDR: $cidr_block"
    
    # Create bridge
    local bridge_name="br-$vpc_name"
    create_bridge "$bridge_name"
    
    # Store VPC configuration
    mkdir -p "$VPC_DIR"
    echo "CIDR=$cidr_block" > "$VPC_DIR/$vpc_name.conf"
    echo "BRIDGE=$bridge_name" >> "$VPC_DIR/$vpc_name.conf"
    echo "GATEWAY=${cidr_block%.*}.1" >> "$VPC_DIR/$vpc_name.conf"
    
    log_info "âœ… VPC $vpc_name created successfully"
}

create_subnet() {
    local vpc_name="$1"
    local subnet_name="$2"
    local subnet_cidr="$3"
    local subnet_type="${4:-private}"
    
    log_info "ðŸ”§ Creating subnet: $subnet_name (CIDR: $subnet_cidr, Type: $subnet_type)"
    
    if ! vpc_exists "$vpc_name"; then
        log_error "VPC $vpc_name not found"
        return 1
    fi
    
    # Load VPC config
    source "$VPC_DIR/$vpc_name.conf"
    
    # Create network namespace
    local ns_name="ns-$vpc_name-$subnet_name"
    delete_namespace "$ns_name"  # Clean up first
    create_namespace "$ns_name"
    
    # Create veth pair with simpler names
    local veth_host="veth-$vpc_name-$subnet_name-h"
    local veth_ns="veth-$vpc_name-$subnet_name-n"
    
    # Clean up any existing interfaces
    ip link delete "$veth_host" 2>/dev/null || true
    
    log_info "Creating veth pair: $veth_host <-> $veth_ns"
    
    # Create veth pair with direct command
    if ! ip link add "$veth_host" type veth peer name "$veth_ns" 2>/dev/null; then
        log_error "âŒ VETH CREATION FAILED - This is usually due to:"
        log_error "1. System security policies (SELinux/AppArmor)"
        log_error "2. NetworkManager conflicts"
        log_error "3. Missing veth kernel module"
        log_error ""
        log_error "Try: sudo setenforce 0  # Temporarily disable SELinux"
        log_error "Or: sudo systemctl stop NetworkManager  # Stop NetworkManager temporarily"
        return 1
    fi
    
    # Move one end to subnet namespace
    log_info "Moving $veth_ns to namespace $ns_name"
    ip link set "$veth_ns" netns "$ns_name"
    
    # Add host end to bridge
    log_info "Connecting $veth_host to bridge $BRIDGE"
    ip link set "$veth_host" master "$BRIDGE"
    ip link set "$veth_host" up
    
    # Configure namespace side
    log_info "Configuring network in namespace $ns_name"
    ip netns exec "$ns_name" ip link set lo up
    ip netns exec "$ns_name" ip link set "$veth_ns" up
    ip netns exec "$ns_name" ip addr add "$subnet_cidr" dev "$veth_ns"
    
    # Set up routing
    log_info "Setting default route via gateway: $GATEWAY"
    ip netns exec "$ns_name" ip route add default via "$GATEWAY"
    
    log_info "âœ… Subnet $subnet_name created successfully in VPC $vpc_name"
}

list_vpcs() {
    log_info "ðŸ“‹ Listing all VPCs:"
    
    if [ ! -d "$VPC_DIR" ] || [ -z "$(ls -A "$VPC_DIR" 2>/dev/null)" ]; then
        echo "No VPCs found"
        return
    fi
    
    for config_file in "$VPC_DIR"/*.conf; do
        local vpc_name=$(basename "$config_file" .conf)
        echo ""
        echo "VPC: $vpc_name"
        source "$config_file"
        echo "  CIDR: $CIDR"
        echo "  Bridge: $BRIDGE"
    done
}

# Main CLI handler
main() {
    init_log
    
    case "$1" in
        create-vpc)
            if [ $# -lt 3 ]; then
                log_error "Usage: create-vpc <name> <cidr>"
                exit 1
            fi
            create_vpc "$2" "$3"
            ;;
        create-subnet)
            if [ $# -lt 4 ]; then
                log_error "Usage: create-subnet <vpc> <name> <cidr> [type]"
                exit 1
            fi
            create_subnet "$2" "$3" "$4" "$5"
            ;;
        list-vpcs)
            list_vpcs
            ;;
        *)
            echo "Usage: $0 {create-vpc|create-subnet|list-vpcs}"
            echo "  create-vpc <name> <cidr>"
            echo "  create-subnet <vpc> <name> <cidr> [type]"
            echo "  list-vpcs"
            ;;
    esac
}

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_error "This script must be run as root for network operations"
    exit 1
fi

main "$@"
EOF

chmod +x vpcctl
